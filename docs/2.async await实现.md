---
highlight: a11y-dark
---

# 1. async/await 基础

## 1.1 async/await 语法

### 1.1.1 返回 Promise 对象

async 函数如果使用 return 返回了值（如果没有 return 则返回 undefined），这个值会被 Promise.resolve() 包装成一个 Promise 对象。

```js
async function foo() {
  return 3;
}

foo().then(console.log);
// 3
```

### 1.1.2 Promise 对象的状态变化

async 函数放回的 Promise 对象，必须等到内部所有的 await 命令后面的 Promise 对象执行完，才会发生状态改变。

如果有一个 await 命令后面的 Promise 对象变为 rejected，那么整个 async 函数就会中断执行。

```js
async function fetchUserData() {
  // 1. 先获取用户基本信息
  await fetch("/api/user/profile");
  // 2. 然后获取用户订单历史
  await fetch("/api/user/orders");
  // 3. 最后获取用户偏好设置
  await fetch("/api/user/preferences");

  return "所有用户数据加载完成";
}

fetchUserData().then(console.log);
// 输出: "所有用户数据加载完成"
```

上面代码中，函数 fetchUserData 内部有三个操作：获取用户基本信息、获取用户订单历史、获取用户偏好设置。只有这三个操作全部完成，才会执行 then 方法里面的 console.log。

### 1.1.3 await 命令

await 命令后面可以跟一个 Promise 对象，也可以跟一个普通值。

如果是 Promise 对象，await 会阻塞后面的代码，直到 Promise 对象 resolve，然后得到 resolve 的值。

如果是普通值，await 会返回这个值本身。

```js
// 示例1: await后面跟Promise对象
async function example1() {
  const result = await new Promise((resolve) => {
    setTimeout(() => resolve("异步操作完成"), 1000);
  });
  console.log(result); // 输出: "异步操作完成"
}

// 示例2: await后面跟普通值
async function example2() {
  const num = await 123;
  console.log(num); // 输出: 123
}

// 示例3: await处理异步函数
async function fetchData() {
  return "数据加载完成";
}

async function example3() {
  const data = await fetchData();
  console.log(data); // 输出: "数据加载完成"
}
```

> 从 ES2022 开始，await 可以在模块的顶层单独使用，不需要包裹在 async 函数中。
>
> 主要特点：1. 只能在 ES6 模块中使用，不能在 CommonJS 模块中使用。2. 模块会等待顶层 await 执行完成才会执行导入该模块的代码。3. 可以简化异步模块的初始化过程。4. 使模块能够异步加载资源。
>
> 使用场景：1. 模块初始化时需要异步加载配置。2.动态导入依赖。3.异步资源加载。

### 1.1.4 错误处理

如果 await 后面的异步操作出错，那么等同于 async 函数返回的 Promise 对象被 reject。如果 await 后面的 Promise 对象抛出错误，那么可以使用 try...catch 来捕获错误。

```js
// 异步操作出错导致Promise被reject
async function example1() {
  await Promise.reject("出错了！");
  return "这行不会执行";
}

example1().catch((err) => {
  console.log(err); // 输出: "出错了！"
});

// 使用try...catch捕获错误
async function example2() {
  try {
    await Promise.reject("出错了！");
  } catch (err) {
    console.log("捕获到错误:", err); // 输出: "捕获到错误: 出错了！"
    return "错误已处理";
  }
}

example2().then(console.log); // 输出: "错误已处理"
```

## 1.2 async/await 的使用

async 函数返回一个 Promise 对象，可以使用.then 方法添加回调函数。而 await 会阻塞后面的代码，直到 Promise 完成。下面是一个例子：

```js
async function example() {
  console.log("开始");
  await new Promise((resolve) => setTimeout(resolve, 1000));
  console.log("结束");
}

example().then(() => console.log("Promise完成"));
// 输出: "开始" "结束" "Promise完成"
```

上面的 example 函数，函数前面放一个 async，表示函数是异步函数，调用该函数时，会立即返回一个 Promise 对象。而 await 会阻塞后面的代码，直到 Promise 完成。所以输出顺序是："开始"，1 秒后输出"结束"，最后输出"Promise 完成"。
![example执行顺序图](./images/2-1.svg)

实际开发中，我们经常会遇到多个异步操作需要顺序执行的情况。比如，在一个后台管理系统中，用户登录后需要获取权限、加载菜单和初始数据。使用async/await可以让这些异步操作的代码更加清晰易读：

```js
async function initAdminDashboard(username, password) {
  try {
    // 1. 用户登录验证
    const loginResult = await userLogin(username, password);
    console.log(`登录成功，获取到token: ${loginResult.token}`);
    
    // 2. 获取用户权限
    const permissions = await getUserPermissions(loginResult.userId);
    console.log(`用户权限列表: ${permissions.join(', ')}`);
    
    // 3. 加载系统菜单
    const menus = await loadMenusByPermissions(permissions);
    console.log(`加载了${menus.length}个菜单项`);
    
    return {
      user: loginResult,
      permissions: permissions,
      menus: menus,
    };
  } catch (error) {
    console.error('初始化管理面板失败:', error);
    throw error;
  }
}

// 使用
initAdminDashboard('admin', 'password123')
  .then(result => {
    // 渲染页面
    renderDashboard(result);
  })
  .catch(err => {
    // 显示错误信息
    showError(err.message);
  });
```

在这个例子中，我们使用async/await顺序执行了三个步骤：用户登录、获取权限、加载菜单。每一步都依赖于前一步的结果，使用async/await可以让代码按照同步的方式编写，避免了回调地狱，同时保持了异步执行的效率。

## 2.1 Generator 语法与特性

## 2.2 Generator 在异步编程中的应用

# 3. 使用 Generator 模拟 async/await

## 3.1 实现原理与思路

## 3.2 generatorToAsync 函数实现

## 3.3 测试与验证
