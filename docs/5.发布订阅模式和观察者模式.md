# 一、引言

观察者模式和发布订阅模式是前端开发中最常用的设计模式之一，它们都用于解决对象之间的通信问题，但实现方式和适用场景有所不同。

在前端开发中，这两种模式的应用非常广泛：

- **Vue.js 的响应式系统**：Vue 利用观察者模式实现数据与视图的自动同步
- **Redux/Vuex 等状态管理库**：基于发布订阅模式构建的状态管理解决方案

这两种模式看似相似，但在实现细节和应用场景上有着微妙的差别，很多开发者往往难以准确区分。本文将介绍这两种设计模式的核心概念、实现方法以及如何正确区分和应用它们。

# 二、观察者模式：直接沟通的艺术

## 2.1 核心思想与角色

核心思想：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。

首先举个例子描述一下观察者模式，假设你所在的城市有一个气象台，它会定期发布天气变化信息。你和其他关心天气的人可以订阅这个气象台的服务，当气象台发布新的天气信息时，所有订阅的人都会收到通知。这个过程就是一个典型的观察者模式。

在上述过程中，气象台只有一个，但是你和其他订阅气象台服务的人可以有多个，这多个订阅气象台服务的人就是观察者，他们订阅了气象台的服务，气象台就是被观察者，当气象台发布新的天气信息时，会通知所有订阅的人。

观察者模式中两个重要的角色就是被观察者（Observable）和观察者（Observer）。

## 2.2 实现要点分析

结合上面的例子，我们知道了，在观察者模式中，两个重要的角色是一定要出现的——被观察者和观察者。用面对对象的话来说，就是需要有两个类。

首先我们来看被观察者，回忆上面的例子，气象台服务收系是需要有一个被订阅的功能，然后还需要一个通知订阅人的功能，最后还需要一个取消订阅的功能。对应到观察者这个类里，就是需要一个添加观察者的方法，一个移除观察者的方法，一个通知所有观察者的方法。

观察者这个类，对应到上面的例子，订阅了天气服务的人，在观察者模式里，就是需要有一个方法，用于接收通知。这个方法就是观察者类里的一个方法，用于接收通知。

## 2.3 代码实现

```js
/**
 * Subject类 - 被观察者
 * @class
 * @description 维护观察者列表,管理状态变化并通知观察者
 */
class Subject {
  /**
   * @constructor
   * @description 初始化观察者列表和状态
   */
  constructor() {
    this.observers = []; // 观察者列表
  }

  /**
   * 添加观察者到列表
   * @param {Observer} observer - 要添加的观察者对象
   * @description 如果观察者不存在则添加到列表中
   */
  addObserver(observer) {
    if (!this.observers.includes(observer)) {
      this.observers.push(observer);
    }
  }

  /**
   * 从列表中移除观察者
   * @param {Observer} observer - 要移除的观察者对象
   * @description 通过过滤方式移除指定观察者
   */
  removeObserver(observer) {
    this.observers = this.observers.filter((obs) => obs !== observer);
  }

  /**
   * 通知所有观察者
   * @description 遍历观察者列表并调用每个观察者的update方法
   */
  notify() {
    this.observers.forEach((observer) => observer.update(this));
  }
}

/**
 * Observer类 - 观察者
 * @class
 * @description 实现观察者模式中的观察者角色
 */
class Observer {
  constructor() {}
  /**
   * 更新方法
   * @param {any} data - 接收到的数据
   * @description 当被观察者状态改变时被调用
   */
  update(data) {
    console.log(`收到通知`, data);
  }
}
```

结合上面的例子，我们来实现一个气象台和订阅人的代码：

```js
class WeatherStation extends Subject {
  constructor() {
    super();
    this.weatherData = null;
    this.observers = [];
  }
  setWeatherData(data) {
    this.weatherData = data;
    this.notify();
  }
  getWeatherData() {
    return this.weatherData;
  }
}
class Person extends Observer {
  constructor(name) {
    super();
    this.name = name;
  }
  update(data) {
    console.log(`${this.name} 收到通知:${data}`);
  }
}
```

下面我们可以 new 一个 WeatherStation 对象（气象台），它可以调用 setWeatherData 方法来修改天气预报，每次天气发送变化，都会通知所有订阅者，这就实现我们核心思想里面的：当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。

```js
const weatherStation = new WeatherStation();
const person1 = new Person("张三");
const person2 = new Person("李四");

// 订阅天气通知
weatherStation.addObserver(person1);
weatherStation.addObserver(person2);

// 天气变化，通知所有订阅者
weatherStation.setWeatherData("天气晴朗，温度25摄氏度");
weatherStation.removeObserver(person1);
weatherStation.setWeatherData("天气阴雨，温度23摄氏度");
```

# 三、发布订阅模式：加个中间人

## 3.1 核心思想与角色

核心思想：通过一个消息中心（消息总线）来传递消息，消息中心会保存所有订阅者，当有消息发布时，会通知所有订阅者。

同样举个例子，假设有一个新闻发布平台，该平台每天会发布不同类别的新闻（如体育、科技、财经等）。用户可以订阅自己感兴趣的类别，当有相关新闻发布时，平台会自动将新闻推送给订阅了该类别的用户。这个过程就是一个发布订阅模式。

在上述过程中，发布者（新闻发布平台）和订阅者（用户）是两个不同的角色，发布者需要有一个消息中心（消息总线），用于保存所有订阅者，当有消息发布时，会通知所有订阅者。订阅者需要有一个订阅方法，用于订阅消息，当有消息发布时，会收到通知。

发布订阅中的三种角色是：发布者、订阅者、消息中心。

## 3.2 实现要点分析

## 3.3 代码实现

# 四、傻傻分不清？一图看懂两者区别

## 4.1 结构对比图

观察者模式和发布订阅模式在结构上有着明显的区别，下图差异：

![观察者模式vs发布订阅模式结构对比](./images/5-1.svg)

从上图可以看出：

- **观察者模式**：Subject（主题/被观察者）直接与 Observer（观察者）进行交互，是一种**直接通知**的机制，两者之间存在**强耦合**关系。
- **发布订阅模式**：Publisher（发布者）和 Subscriber（订阅者）之间通过 Event Channel（事件中心）进行通信，是一种**间接通知**的机制，两者之间存在**松耦合**关系。

## 4.2 关键实现差异

### 通信方式

**观察者模式**的工作流程：

![观察者模式工作流程](./images/5-3.svg)

1. 观察者向主题（被观察者）直接注册自己
2. 当主题状态发生变化时
3. 主题直接通知所有已注册的观察者

**发布订阅模式**的工作流程：

![发布订阅模式工作流程](./images/5-2.svg)

1. 订阅者向事件中心订阅特定事件
2. 发布者向事件中心发布事件
3. 事件中心通知相关订阅者
4. 订阅者接收并处理事件


# 五、总结：不再傻傻分不清
